#pragma once
#include "include.h"
#include "offsets.h"
namespace Vehicle {





	bool Veh_colour;
	void VehColor(float R,float G ,float B) {
		DWORD64 vehiclemanager = read_mem<DWORD64>(localplayer + 0xD30);
		vehiclemanager = read_mem<DWORD64>(vehiclemanager + 0x48);
		vehiclemanager = read_mem<DWORD64>(vehiclemanager + 0x20);
		if (vehiclemanager) {
			if (Veh_colour)
			{
				//write_mem<float>(vehiclemanager + 0xA7, A);
				write_mem<float>(vehiclemanager + 0xAA, R);
				write_mem<float>(vehiclemanager + 0xA9, G);
				write_mem<float>(vehiclemanager + 0xA8, B);

			}
		}
	}

	void FixEngine(float value) {
		DWORD64 vehiclemanager = read_mem<DWORD64>(localplayer + 0xD30);
		if (vehiclemanager) {
			write_mem<float>(vehiclemanager + 0x0280, value);
			write_mem<float>(vehiclemanager + 0x0840, value);
			write_mem<float>(vehiclemanager + 0x0908, value);
			write_mem<float>(vehiclemanager + 0x0844, value);
			write_mem<BYTE>(vehiclemanager + 0x0944,1);
		}
	}

	void GodModeVehicle(bool SEXO) {
		DWORD64 vehiclemanager = read_mem<DWORD64>(localplayer + 0xD30);
		if (vehiclemanager) {
			if (SEXO) {
				write_mem<float>(vehiclemanager + 0x189, 1);

			}
			else {
				write_mem<float>(vehiclemanager + 0x189, 0);

			}
		}
	}


	bool VehAc;
	float VehAc_value1;
	void VehicleAceleration(bool ss , float value) {
		DWORD64 vehiclemanager = read_mem<DWORD64>(localplayer + 0xD30);
		DWORD64 HAndLing = read_mem<DWORD64>(vehiclemanager + 0x938);

		if (!VehAc) {
			VehAc_value1 = read_mem<float>(HAndLing + 0x4C);
			VehAc = true;
		}

		if (vehiclemanager) {

			if (ss) {
				write_mem<float>(HAndLing + 0x4C, value);
			}
			else {
				VehAc = false;
				write_mem<float>(HAndLing + 0x4C, VehAc_value1);
			}
		}
	}



	bool VehBreak;
	float VehBreak_value;
	void VehicleBrakeForce(bool ss, float value) {
		DWORD64 vehiclemanager = read_mem<DWORD64>(localplayer + 0xD30);
		DWORD64 HAndLing = read_mem<DWORD64>(vehiclemanager + 0x938);

		if (!VehBreak) {
			VehBreak_value = read_mem<float>(HAndLing + 0x6C);
			VehBreak = true;
		}

		if (vehiclemanager) {

			if (ss) {
				write_mem<float>(HAndLing + 0x6C, value);
			}
			else {
				VehAc = false;
				write_mem<float>(HAndLing + 0x6C, 1);
			}
		}
	}

	void VehicleGravity(bool ss) {
		DWORD64 vehiclemanager = read_mem<DWORD64>(localplayer + 0xD30);
		if (vehiclemanager) {
			if (ss) {
				write_mem<float>(vehiclemanager + 0x189, 60.0);
			}
			else {
				write_mem<float>(vehiclemanager + 0x189, 9.8);
			}
		}
	}
}

namespace Weapons {


	bool NoRecoilTestBool;
	void NoRecoilTest(bool sexy) {
		DWORD64 weaponmanager = read_mem<DWORD64>(localplayer + 0x10D8);
		weaponmanager = read_mem<DWORD64>(weaponmanager + 0x20);
		if (!NoRecoilTestBool)

		{
			write_mem<float>(weaponmanager + 0x2F4, 0.f);
		}

	}

	void SetAmmoType(float value){
		DWORD64 WeaponMGR = read_mem<DWORD64>(localplayer + 0x10D8);
		if (WeaponMGR) {
			write_mem<float>(WeaponMGR + 0x20, value);
		}
	}
	bool Explosive;
	void SetAmmoExplosiveType(float value) {
		DWORD64 WeaponMGR = read_mem<DWORD64>(localplayer + 0x10D8);
		if (WeaponMGR) {
			write_mem<float>(WeaponMGR + 0x24, value);
		}
		if (!Explosive) {
			write_mem<float>(WeaponMGR + 0x24, 1);

		}
	}
	void FillAmmo(float value) {
		DWORD64 LocalPL = read_mem<DWORD64>(localplayer + 0x10D8);
		DWORD64 weapon = read_mem<DWORD64>(LocalPL + 0x20);
		weapon = read_mem<DWORD64>(LocalPL + 0x60);
		weapon = read_mem<DWORD64>(LocalPL + 0x8);
		weapon = read_mem<uint32_t>(LocalPL + 0x8);

		if (weapon){
			write_mem<float>(weapon + 0x18, value);
		}
	}



	bool NoRec;
	float NoRecValue;
	void NoRecoil(bool sexy) {
		DWORD64 LocalPL = read_mem<DWORD64>(localplayer + 0x10D8);
		DWORD64 weaponmanager = read_mem<DWORD64>(LocalPL + 0x20);

		if (!NoRec){
			NoRecValue = read_mem<float>(weaponmanager + 0x2F4);
			NoRec = true;
		}

		if (weaponmanager)
		{
			if (sexy) {
				write_mem<float>(weaponmanager + 0x2F4, 0);
			}
			else {
				write_mem<float>(weaponmanager + 0x2F4, NoRecValue);
				NoRec = false;
			}
		}
	}

	bool NoSpreads;
	float NoSpreadValue;
	void NoSpread(bool sexy) {
		DWORD64 weaponmanager = read_mem<DWORD64>(localplayer + 0x10D8);
		weaponmanager = read_mem<DWORD64>(weaponmanager + 0x20);

		if (!NoSpread) {
			NoSpreadValue = read_mem<float>(weaponmanager + 0x74);
			NoSpreads = true;
		}
		if (weaponmanager)
		{
			if (sexy) {
				write_mem<float>(weaponmanager + 0x74, 0);
			}
			else {
				write_mem<float>(weaponmanager + 0x74, NoSpreadValue);
				NoSpreads = false;
			}
		}
	}


	bool NoReloa;
	float NoReloadValue;
	float NoReloadValue2;
	void NoReaload(bool sexy) {
		DWORD64 weaponmanager = read_mem<DWORD64>(localplayer + 0x10D8);
		weaponmanager = read_mem<DWORD64>(weaponmanager + 0x20);

		if (!NoReloa) {
			NoReloadValue = read_mem<float>(weaponmanager + 0x130);
			NoReloadValue2 = read_mem<float>(weaponmanager + 0x134);
			NoReloa = true;
		}
		if (weaponmanager) {
			if (sexy) {
				write_mem<float>(weaponmanager + 0x130, 10.f);
				write_mem<float>(weaponmanager + 0x134, 10.f);
			}
			else {
				write_mem<float>(weaponmanager + 0x130, NoReloadValue);
				write_mem<float>(weaponmanager + 0x134, NoReloadValue2);
				NoReloa = false;
			}
		}
	}

}



namespace Player {



	float GetHealth() {
		if (localplayer) {
			return read_mem<float>(localplayer + 0x280);
		}
	}

	float GetArmor() {
		if (localplayer) {
			return read_mem<float>(localplayer + 0x14B8);
		}
	}

	float GetMaxHealth() {
		if (localplayer) {
			return read_mem<float>(localplayer + 0x2A0);//0x02A0
		}
	}

	void Godmode(bool value) {
		if (localplayer) {
			if (value)
			write_mem<bool>(localplayer + 0x189, 1);

			if (!value)
				write_mem<bool>(localplayer + 0x189, 0);

		}
	}

	void FreezePlayer(int value) {
		uintptr_t playerinfo = read_mem<uintptr_t>(localplayer + 0x10C8);
		if (localplayer) {
			if (value)
				write_mem<int32_t>(localplayer + 0x238, 2);
		}
	}

	void Invisible(bool value) {
		if (localplayer) {
			if (value) {
				write_mem<BYTE>(localplayer + 0x2C, 0x1);
			}
			else {
				write_mem<BYTE>(localplayer + 0x2C, 0x37);
			}
		}
	}
	bool NoClipBool;
	void NoClip(bool value)
	{
		if (!NoClipBool)
		{
			D3DXVECTOR3 pos = read_mem<D3DXVECTOR3>(localplayer + 0x90);
			uintptr_t navig = read_mem<uintptr_t>(localplayer + 0x30);
			write_mem<D3DXVECTOR3>(navig + 0x30, D3DXVECTOR3(0, 0, 0));

			if (GetAsyncKeyState(0x57) & 0x8000) {
				write_mem<D3DXVECTOR3>(localplayer + 0x320, D3DXVECTOR3(0, 0, 0));
				uint64_t camera = read_mem<uintptr_t>(camera + 0x0);
				D3DXVECTOR3 angles = read_mem<D3DXVECTOR3>(camera + 0x03D0);
				if (angles == D3DXVECTOR3(0, 0, 0))
					angles = read_mem<D3DXVECTOR3>(camera + 0x40);
				D3DXVECTOR3 npos = pos;
				npos.x += (angles.x * 2);
				npos.y += (angles.y * 2);
				npos.z += (angles.z * 2);
				write_mem<D3DXVECTOR3>(localplayer + 0x90, npos);
				write_mem<D3DXVECTOR3>(navig + 0x50, npos);
			}
		}
	}
	void InfStam(bool value) {
		if (localplayer) {
		
			if (value) {

				uintptr_t Playerinfo = read_mem<uintptr_t>(localplayer + 0x10C8);
				write_mem<float>(Playerinfo + 0x0CF4, 100);
			}
		
		}


	}

	void SetArmor(float armor) {
		if (localplayer) {
			write_mem<float>(localplayer + 0x14B8, armor);
		}
	}

	void SetHealth(float health) {
		if (localplayer) {
			write_mem<float>(localplayer + 0x280, health);
			write_mem<float>(localplayer + 0x2A0, health);
		}
	}

	void SpeedWalk(bool sexy, float Speed) {
		uintptr_t playerinfo = read_mem<uintptr_t>(localplayer + 0x10C8);
		if (localplayer) {
			if (sexy) {
				write_mem<float>(playerinfo + 0xCF0, Speed);
			}
			else if (!sexy) {
				write_mem<float>(playerinfo + 0xCF0, 1);
			}
		}
	}



}